Ep 7 (Boxed vs Unboxed)
------------------------
(This part is alr talked about in my notes on ep6)
Doubles stored in ArrayOfDoubles aren't added with 0x1000000000000 (2^48) <- This is unboxed 
a = [13.37]
a[0] in memory will be 0x402abd70a3d70a3d

Doubles stored in ArrayOfContiguous are added with 0x1000000000000        <- This is boxed
a = [13.37,{}]
a[0] in memory will be 0x402bbd70a3d70a3d

This is done so that certain doubles (that start with 0x0000) doesnt get confused as a pointer because of NaN-encoding
This only happens if our value is a JSValue
Storing a double as a JSValue is necessary when the array has various different types
(cause JSValue can store a lot of different types using NaN-encoding)

struct.pack() js edition
--------------------------
How can you convert 0x402abd70a3d70a3d to 13.37 in javascript?
If we look at Saelo's utility library, he implemented it using something called ArrayBuffer()

buf = new ArrayBuffer(8);
u32 = new Uint32Array(buf);
f64 = new Float64Array(buf);

now both u32 and f64 are using the same array

f64[0] = 5.3678009605058e-310  (doubles are 64bit) 
5.3678009605058e-310
>>> u32[0].toString(16)
7de890
>>> u32[1].toString(16)
62d0
>>> (u32[1]*0x100000000+u32[0]).toString(16)
62d0007de890

The ArrayBuffer() kinda did the conversion for us,nice.
