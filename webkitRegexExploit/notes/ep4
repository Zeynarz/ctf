Ep 4 (JIT, Just-in-time compiler)
-------------------------------------
https://webkit.org/blog/6411/javascriptcore-csi-a-crash-site-investigation-story/

What is a JIT?
--------------
the JIT just compiles javascript byte code into machine code (opcodes) 
just like how you compile C code

What are js byte code?
-----------------------
Js byte code are translated by an interpreter and can be immediately executed if there is a js vm
byte code executed by js vm wont be highly optimized, so great for executing code that is only ran once
for code that keeps getting reused, need to optimize it by using JIT (?)

//TODO: learn more bout js virtual machines

Tiers of execution engines
----------------------------
tier 1: the LLInt interpreter                 (least optimized)
tier 2: the Baseline JIT compiler
tier 3: the DFG (Data flow graph)   JIT
tier 4: the FTL (Faster Than Light) JIT       (most optimized)

(is LLInt interpreter a js virtual machine?)

The LLInt interpreter just loops over js byte code and then execute each instruction
But when a function/expression is getting called a lot (hot), the code needs to be optimized
To optimize the function javascript will JIT/compile the function

from (https://webkit.org/blog/3362/introducing-the-webkit-ftl-jit/)
--------------------------------------------------------------------------
The first execution of any function always starts in the interpreter tier. 
As soon as any statement in the function executes more than 100 times, or the function is called more than 6 times (whichever comes first), execution is diverted into code compiled by the Baseline JIT.
This eliminates some of the interpreterâ€™s overhead but lacks any serious compiler optimizations. 
Once any statement executes more than 1000 times in Baseline code, or the Baseline function is invoked more than 66 times, we divert execution again to the DFG JIT. 
--------------------------------------------------------------------------

TLDR: the more times the function gets executed the higher the tier the JIT

        Statement  Function
LLInt     100         6
Baseline  1000        66

Tier 2 Baseline JIT
--------------------
(from jit.cpp)
// When the LLInt determines it wants to do OSR entry into the baseline JIT in a loop,
// it will pass in the bytecode offset it was executing at when it kicked off our
// compilation. We only need to compile code for anything reachable from that bytecode
// offset.

(from https://stackoverflow.com/questions/9105505/differences-between-just-in-time-compilation-and-on-stack-replacement/9105846#9105846)
---------------------------------------------------------------------------------------------
On Stack Replacement (OSR) is a technique for switching between different implementations of the same function. 
For example, you could use OSR to switch from interpreted or unoptimized code to JITed code as soon as it finishes compiling.
---------------------------------------------------------------------------------------------

Basically OSR is just a way to switch from byte code to JIT code 

Tier 3 DFG(Data Flow Graph) JIT
---------------------------------
DFG starts by compiling byte code into DFG CPS form 

CPS means continuous-passing style 
with CPS, code doesnt use returns but just passes onto the next function

DFG CPS reveals the data flow relationships between operations,
with this information, DFG can start to guess about types and if DFG believes types dont change,
it starts to remove checks

For example (how I imagine it)
DFG sees that int variable a -> operations -> int variable a
so DFG doesnt check if a is still an integer after the statement

with less checks,code execution speed speeds up

Tier 4 FTL(Faster Than Light) JIT
-----------------------------------
The FTL JIT makes more assumptions about the code/remove more checks than the DFG JIT
to make the code even more optimized and run even faster

Security measures
-------------------
To prevent people abusing the removed checks, for example suddenly changing the type of a variable when JIT assumed that it would still be the same
Developers marked dangerous functions (for example functions that could change layout of an array) by calling a function called clobberworld()
clobberworld will break all assumptions of types 


