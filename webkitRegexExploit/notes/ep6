Ep 6 (fakeobj() Turning an address leak to memory corruption)
---------------------------------------------------------------
addrof() was reading object as doubles
fakeobj() is essentially about writing doubles as ptrs, writing a ptr into an ArrayWithContiguous

How doubles differ in arrayOfDoubles and arrayOfContiguous
--------------------------------------------------------------
In an ArrayWithContiguous, NaN-encoding is used, objects have 0000s infront of them etc
If you manage to insert a double which has 0000s infront of them in memory, javascript will follow the NaN encoding
and think that the double is a ptr/object in memory.

Well what if 
a = [{},13.37] #Array of contiguous
a[1] = 5.367800960505e-310  (5.367800960505e-310 in memory is 0x000062d0007de880)

Will javascript think that a[1] is an object/ptr ? Not really
The devs of jsc knew that this will happen, so in order to prevent this
In ArrayOfContiguous, all doubles are added with an additional 0x1000000000000 to prevent this

So in reality, 5.367800960505e-310 in memory is 0x000062d0007de880 + 0x1000000000000
which is 0x000162d0007de880

But in ArrayOfDoubles,everything is a double, so javascript doesnt have to add 0x1000000000000 to make sure its
not a ptr
so if 
a = [5.367800960505e-310] 
a[1] in memory will be 0x000062d0007de880

How can we abuse this?

How to create a fakeobject
------------------------------
In Linus's exploit, this is how he created a fake object.

(Addr Setter is DFG JITed)
var AddrSetter = function(array) {
    array = getarray();
    "abc".match(reg);
    array[0] = dbl;
}

regexLastIndex.toString = function() {
    //Array with contiguous
    array[0] = {};
    return "0";
};
reg.lastIndex = regexLastIndex;

DFG JIT thinks that in Addr Setter, array is always an ArrayOfDouble since it didn't add elements of other types
When Addr Setter is called, .match() is executed and since lastIndex is not a number, internal regex code called
toString to try to convert lastIndex to a number

When toString is called,the array becomes an arrayWithContiguous because an object is inserted into the array.
But AddrSetter still thinks that the array is an arrayOfDoubles so it inserted the double WITHOUT NaN-encoding,
it didnt add 0x1000000000000 to the double

Boom, a ptr written into an ArrayWithContiguous
(Simply put, JIT thought it was still an ArrayOfDouble but in reality it was an ArrayWithContiguous)

utilizing fakeobj()
--------------------
So you now have the ability to create a ptr in an array , now what?
If you create a ptr = 0x4141414141
Of course thats gonna crash since that is invalid memory, 
if you create a ptr that points to some ascii characters
ptr: 0x65666768, javascript will think that the pointer is a string

If you want to make an object,the ptr needs to point to somewhere that looks like an object
This is an example of an object:

a = {}
a.a = 1
(lldb) x/4gx 0x62d0000d4080
0x62d0000d4080: 0x0100160000000126 0x0000000000000000
0x62d0000d4090: 0xffff000000000001 0x0000000000000000

Well since we have the addrof() pointer we can get the ptr of any object
We can theoretically create a ptr (using fakeobj()) that points to 0x62d0000d4090, and craft a fake object there
We can abuse the fact that properties for objects that dont have butterflys, are stored in the object

If 
a.a = JSCellHeader
a.b = butterfly
a.c = properties

then a would look like 
0x62d0000d4080: 0x0100160000000126 0x0000000000000000
0x62d0000d4090: 0x0100160000000126 0x0000000000000000
0x62d0000d40a0: 0xffff000000000001 0x0000000000000000

If we use fakeobj() to craft a ptr to 0x62d0000d4090 now, we can create an object that we have total control over

Making JSCellHeader
---------------------
Well the JSCellHeader contains flags and a structureid
We can just copy the flags but how can we make a valid structure id?
Well we learned that structure ids are used to keep track of properties, so if we create
A LOT of objects (for example 5000) that have properties,we can predict that around 5000+ structure ids are created
So we can simply set our structure id to like 0x1000 and it would probably be a valid structure id
(Remember that in ArrayOfContiguous, doubles are added with 0x1000000000000)

Well how can we create a property which is equal to 0x0000000000000000 in memory, since null is 0x2
well its actually really easy,we can just delete the property and it would be 0x0

setupObject = {}
setupObject.a = (0x0100160000001000 in double form)
setupObject.b = 1
setupObject.c = 0x1337
delete setupObject.b

setupAddr = addrof(setupObject)
fakeObject = fakeobj(setupAddr + 0x10 in double form)
fakeObject.a will now return 0x1337 !

if fakeObject.a = 0x50, setupObject.c = 0x50

Now we can create any object, that we have total control over

Linus's Exploit
----------------
Linus practically did the same thing , but after he created a ton of Float64 objects to guarentee a valid structure id , he created several WebAssembly.Memory objects

The fake object he created would have the structure id of one of the Float64 objects he sprayed
But after the fake object has been created, he slowly incremented the structure id of the fake object
so that the structure id of the fake object was equals to the structure id of a WebAssembly.Memory object
So now his fake object was a WebAssembly.Memory object

Epic
